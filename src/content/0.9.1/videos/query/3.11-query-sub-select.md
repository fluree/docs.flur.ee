### Transcript

We are going to look at some options that you can specify on interior levels of your query. If we go to our documentation, you will find all of the options that you can specify in 'Query/Advanced Query/Sub-Selection Options' (/docs/query/advanced-query#sub-selection-options). And this might look different than it does on my screen (depending on your version) - there might be more sub-select options by the time you are looking at this! In this video, we are going to talk about `_limit`, `_recur`, and `_component`. 

I am heading over to my user interface, and I am starting with a pretty basic query: `"select": ["*"], "from": "person"` and I want to expand my query, I am actually going to do `"select": ["person/handle"], "from": "person"` - just to clean up our result set a little bit. And I am going to expand so that I see the `"person/handle"` and the `"person/favArtists"`. So this is just an example of crawling the graph which we have covered in previous videos. So now I see `"zsmith"` has one favorite artist, and `"jdoe"` has three favorite artists. And you can think of an example where a user in our application has 20 favorite artists or 30 favorite artists - we don't necessarily want to see every single artist that each person likes, we might just want to see one or two. So what we can do to limit the number of artists we see is to specify a 'sub-select option'.

We can't specify `_limit` at the top level here, because that limits the number of people that we see. That's not what we want, we want to limit something at a deeper level in our graph - we want to limit the number of favorite artists. So what we can do is we can go into this map, `"person/favArtists"` and we go into the array that specifies all of the predicates that we want to see for each artist, we are going to add a new map, and we are going to add `"_limit"` and set a new limit. So just to be really drastic here, I going to set a limit to `0`, so we see no favorite artists. but I can set a limit to `1` - each person has 1 favorite artist, `2`, etc...so that is a limit, and again, all of these sub-select options start with an underscore.

The next option that we can look at for sub-select is recursion. So, in our dataset, we have a predicate called `"person/follows"`, and `"person/follows"` is a reference to another person. So `"zSmith"` follows `"jdoe"`, and `"jdoe"` follows `"zsmith"`. And I am going to actually add a new follow relationship here, so that we can see some better recursion. I want `"ePoe"` to follow `"zsmith"`. So now we see `"ePoe"`follows `"zsmith"`, `"zsmith"` follows `"jdoe"`. So now we have a few layers of connection, and you might not have the same people as me, but you can just add an additional person follows in the same way that have done here but replace the handles with the handles that you have in your database. Anyway, so I can just add a sub-select option in the same way that I added my `"_limit"`, I can do `"_recur"` and in this `"_recur"`, I specify the amount of times that I want the graph to follow that relationship. So, if I do `"_recur": 0` - you see that it doesn't follow that relationship even once, it just gives our `_id` but it doesn't give me any additional predicates. If I do `"_recur": 1`, I see information about `"ePoe"` and the person that `"ePoe"` follows - but I don't see the information that the person that `"ePoe"` follows, follows. If I do `"_recur": 2`, you can see `"ePoe"` follows `"zsmith"`, and `"zsmith"`follows `"jdoe"`. So that is recursion, and just one last point: so if I do `"_recur": 5`, I only see the deepest level of recursion that doesn't repeat. So `"jdoe"` follows `"zsmith"`, so this person is - this person, so if we kept following that relationship then this graph would just repeat, so instead of showing all of those results, it just stops.

So, finally the last thing that we can look at is 'component'. So in order to demonstrate `"_component"`, I am going to show you a reverse reference which is `"chat/_person"`. So all of these different people, our first three people don't have any chats, but `"jdoe"` does have a chat. And this is a reverse reference because there is no such predicate 'person/chat', but there is a predicate `"chat/person"`, which is a reference to a person. So we can still follow the relationship from a person to a chat by using this reverse reference syntax - which is something I talk about in a different video. Anyway, in the `"chat"` collection, there is a predicate called `"chat/comments"`. And `"chat/comments"` is a reference to comments made under a chat. And most of the time when you query references, like `"chat/_person"` - only the `"_id"` ofthe subject referenced show up. So, we don't automatically crawl the graph for every single reference that is in our results. We just automatically return a top-layer subject `"_id"` - we don't return any more information, for `"chat/person"` for example. But `"chat/comments"` is a special type of predicate thats called a `"_component"`. 

And components, the way to think about them, is that a component doesn't exist without it's parent. So the reason we do this is if a chat is deleted, we want all of the comments under that chat to be deleted. It doesn't logically make sense for the comments to exist on their own, and that is why we have this special sort of flag which is `"_component"`. When we have a component in our schema an we return a component in our result set, then the results automatically crawl the graph and show us the predicates that belong to that component. That is the default behavior, but we don't always want that to happen, so what we can do is we can add a sub-select option, which is `"_component"` and put `false`. And you can see that when I press "play", these comments will disappear, so watch carefully...and the comments disappear and we just return to that default behavior of returning only the subject `"_id"`for the comments, not all of the additional predicates around it. 

It looks like our docs might have to be updated, so by the time you see this video that option will be there as well. There is an additional sub-select option that we can do, which is `"_as"`. And the reverse reference `"chat/_person"` is not really the nicest name. If we are displaying our results, we might want to change the name of this predicate. So, I can use the sub-select option, which is `"_as"`, and the value of that sub-select option will be the new name of `"_as"`. So, I am going to change that predicate name to `"Person's Chat"` - and as you can see instead of 'chat/_person' which is a little awkward, we now have `"Person's Chat"`.





