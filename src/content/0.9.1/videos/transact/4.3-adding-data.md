### Transcript

So I already have one thing that I need in order to add data - which is an `"_id": "person$myNewPerson1"` (a temporary Id). And now I need to add some information. So under "person", I can add predicates that belong to the "person" collection by just specifying the second part of the name of the predicate. So for example, instead of writing 'person/handle', I can just write `"handle"` here, give my person a handle of `"anythingIwant"`, I can give that person a `"fullName"`, and we will call that person `"Ann E. Thing"`. And I can create a new person. And that person has to have a different temporary Id. So, I am going to change my new temporary Id from `"_id": "person$myNewPerson1"` to `"_id": "person$myNewPerson2"`. I will give that person a `"handle"` of `"ePoe"` and there full name would be `"Edgar Allen Poe"`. And I am going to add a third person, and I am not going to give that person any sort of temporary Id. I am just going to give them a handle of `"zStuart"`.

And I don't have to give every ssingle subject that I am adding to my database the same predicates. I can just give this person a `"handle"`, I don't have to give them anything else - or I can give them 'favNums' or anything like that. So, just to start, I am going to issue this transaction. So I am going to create three new people, and we know they are new people because all of their Ids are strings. And the database knows what database to put them in because the first part of this temporary ID is `"person"`, these are all people. And my keys for this object can be predicates that belong to this "person" collection. So there is such a thing as `"person/handle"`, there is such a thing as `"person/fullName"` - and the value is whatever I want the `"handle"` and `"fullName"` to be. So now I can press "play" and we get back a lot of information, which we talk about in later videos. And now, if I `"select": ["*"], "from": "person"`, I see my new people - zStuart, ePoe, anything - and so here I have all of my new people.

I can issue a another transaction, and this one is going to be a little bit more complicated. SO my transaction has to be inside of square brackets (`[]`), and each item inside of the transaction is inside of curly brackets (`{}`), and every single item has to have a key of `"_id"` where I specify the thing that I am creating or I reference an existing subject.

So, in this case, I am not going to create a new person, I am going to create a new `"artist"`, and the artist collection only has one predicate and that predicate is "artist/name", so I am going to do `"name":` here, and that artist is going to be `"Cezanne"`. And I don't have to have multiple transactions, I can just issue this as a single transaction. And when I query and I `"select": ["*"], "from": "artist"`, I see that I have an new artist, which is `"artist/name": "Cezanne"`. And so, I said that you can just use the second part of a predicate name - you can actually use the full predicate name - that is not going to be an issue. So, if I can think of another artist...`"Monet"` - and if I `"select": ["*"], "from": "artist"` - I can see that we have a new artist named 'Monet'. So again, you can either use the second half of the predicate name or the full namespace predicate name.

And you can actually, although we are not going to talk about it a lot in this video, include predicates that don't belong to that collection - so like `"person/handle"` and that will be added to this subject. If that is confusing for you, then you can just forget it - but that is a feature of graph databases that not all of the predicates that you give to a given subject need to belong to that collection.

Alright, so let's add a new `"person"` with a `"handle": "aBrandon"` and a I am going to use `"person/fullName":`, just to illustrate that you can change back and forth and it doesn't matter: `"Allen Brandon"`. And I am going to create an artist, so `"_id":` and it's going to be 'artist', so I can do `"artist$1"`, and then artists `"name":` is going to be `"Manet"`. So, you can see that I can create more than one type of subject in the same transaction - that's not an issue at all.

And I am actually going to create two new people. I am going to give this person a temporary ID of `"_id": "person$2"`, we are going to call them `"lAlgers"`, and they will be `"Logan Algers"`. And I am going to issue this transaction. Alright, so in the next transaction, you are going to see a use-case for temporary Ids. So, I am going to do the same thing, I am going to create two people, so this will be `"person$1"` and this will be `"person2"`. And the temporary Ids are not actually stored in our database, so I can use the same temporary Id in more than one transaction - it doesn't matter, but I can't use `"person$1"` in the same transaction (that should throw an error). So, I am going to call this person `"aEinstein"`, and this will be `"Albert Einstein"`. And I am going to call this person `"machiavelli"`, and I can't remember his first name, so he will be `"Prince Machiavelli"`.

And if you remember, in our basic schema, we had a predicate with was `"person/follows"` - which can be a reference to a person in our database. So think about in a social network or in a social media page, people follow other people. So, we can specify a subject `"_id"` for a person in `"person/follows"` - so like this... We can use a unique two-tuple, like `"person/handle", "zsmith"`... OR if we want to reference a subject that we are creating in the moment, so `"machiavelli"` doesn't exist yet in our database, but we want `"Albert Einstein"` to follow `"machiavelli"`, so we can just use Machiavelli's temporary Id. So, if he didn't have a temporary Id, if it was just `"person"` - we couldn't reference him. I put follows person, and I guess in this simple transaction, you know we could envision a database that would assume that we mean the other person that we are creating here, but we don't allow that in FlureeDB - so you have actually specify a temporary Id for `"machiaveli"` and use that temporary Id right in this same transaction where you are specifying a `"person/follows"`. So, now we are going to create two new people, and one of those two new people is going to follow the other one of the people that we just created.

Now we can see, there we go, Albert Einstein is created an it is this person with this subject Id, and there are three flakes related to Albert Einstein - one in which we are creating Albert Einstein's handle, `"aEinstein"`, another where we are creating his full name, which is Albert Einstein, and the third which is kind of hard to figure out as it is just a long, and integer, and then another long...that is actually, this is the subject Id for Albert Einstein, "1014" is the subject Id for `"person/follows"`, and this object which ends in 7166 is Machiavelli. And we can check, becasue right here, this is Machiavelli and this connects to Machiavelli. So, actually if we go down (or up depending on the version of FlureeDB that you have), you will see `"tempids"`, and those `"tempids"` are a map where the keys (or the temp Ids that we provided) and the values, or whatever subject Ids those resolved to. So if you are using temp Ids in application, you can issue a transaction like this and you know when you get the results how to figure out, immediately, what subject Ids those temporary Ids resolved to.
