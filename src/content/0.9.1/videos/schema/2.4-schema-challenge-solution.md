### Transcript

In this video, I show you my solution to the DIY schema challenge. Just as a refresher, there were four items that were part of the challenge - so it was creating a database for a human resources application. Our schema should have at least four collections, each collection should have at least two predicates.  There should be at least two 'ref' type predicates in our schema, and we want to use a 'predicate/predicate' that we haven't used before. 

For this video, I'm going to show you my schema in a text editor, just so it's a little easier to see.

So, I create four collections: one is an employee, a department, a project, and a bank account. For my employee, I have an `"employee/fullName"` predicate of type `"string"`, and I have an `"employee/nickname"` predicate type `"string"` as well. So employees might have the same full name, but we want them to have different nicknames. And every single subject or item inside of the Fluree database automatically has a unique ID that's generated, and if we don't have any sort of unique predicate inside of a collection - then we have to refer to that subject using the unique ID.  That is why it is always a good idea to have some sort of unique predicate like 'employee/nickname' in our schema. That way, we have an easy way to refer to a person, we don't have to refer to them by a long system-generated ID.  We can refer to them by their nickname. 

The next thing that we have is an `"employee/bankAccount"`, and I actually used two new 'predicate/predicates' t shat we haven't seen before. The first one that I've used as a predicate `"doc"`, which is actually a good idea to have an all of your predicates. So 'doc' is just an explanation of what we're looking at here, and it's useful to have if you have more than one person working with your database or more than one person using your database - which is usually the case. So, this 'doc' just explains was the predicate is - so this is the bank account for the employees direct deposit.

We also have `"component"` as `true`. So, a component is a feature that only applies to predicates of type `"ref"`, which this is. So this reference is a bank account, and the bank account belongs to the employee. The bank account does not exist outside of the employee, and so we set this component to `true` so that when we delete the employee (if we delete the employee) then the bank account automatically gets deleted. That is what 'component' means, and you can see that description in the documentation. 
 
The next thing that I do is create a "department/name", and that's of type `"string"`, which is `"unique"`. And we have `"department/employees"`, which is a type `"ref"`, and we restrict the collection to `"employee"` (`restrictCollection`) and set `"multi"` to `true`, because presumably department has or could have multiple employees. So, just a note, if we set 'multi' to true doesn't have to have multiple employees - it just means that we could have multiple employees.

The next thing is for projects, I have `"project/name"` of `"type": "string"`, and it is 'unique'. Again, it is always a good idea to have a unique redicate. And I have `"project/employees"` of `"type": "ref"`. We restrict that collection to `"employee"`, we set `"multi"` to `true` - just like our department. 

And then finally, this is a little bit of the curious collection, maybe on first glance - but we have a `"bankAccount/name"` and a `"bankAccount/date"` and that's the only information we have about the bank account. And that might appear weird to people - why would be just have these two things? We don't have an account number, we don't have routing number, or any thing like that. 

So, this isn't a real application, but it's always a good idea to talk about "best practices". When we are talking about a blockchain or even just a standard database, it's never a good idea to store sensitive information about a person in the same place as identifying information. So "sensitive information" would be things like Social Security numbers, information about bank accounts, and "identifying information" would be maybe a person's name or their phone number - any sort of information we can use to identify a person. We want to keep that information separate, so we just have a bank account name and that name is unique. And we have, in this application, we can have another place where you have bank account information. And maybe that is encrypted and maybe that has some other sorts of the protections around it. And all those bank accounts have names, so in order to actually find a person's bank account, we follow "person/bankAccount" and we find `"bankAccount/name"` and then we look at their actual information in a completely different place. And so that's just a good idea for for a general application but it's even more important in blockchain database to have that sort of design, because in a blockhain database because unless you specify otherwise every single piece of history is stored. So, even if we delete a person or we delete a bank account we can go back in time, we could write a "time travel" query and find their bank account information. So, we don't want that to be possible for such sensitive information like this, so we want to have a separation of the identifying information in one place, and in sensitive information in another place. Alright, that was a little bit of it a tangent for this assignment, but I always think there's never a bad time to talk about best practices. 

If you want to share what you created for this assignment, you can share it in the Slack channel for the video lessons. Thank you, bye!